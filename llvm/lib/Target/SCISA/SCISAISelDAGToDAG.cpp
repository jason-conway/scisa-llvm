//===-- SCISAISelDAGToDAG.cpp - A dag to dag inst selector for SCISA ------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file defines a DAG pattern matching instruction selector for SCISA,
// converting from a legalized dag to a SCISA dag.
//
//===----------------------------------------------------------------------===//

#include "SCISA.h"
#include "SCISASubtarget.h"
#include "SCISATargetMachine.h"
#include "llvm/CodeGen/FunctionLoweringInfo.h"
#include "llvm/CodeGen/MachineConstantPool.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/IntrinsicInst.h"
#include "llvm/IR/IntrinsicsSCISA.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/Endian.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

#define DEBUG_TYPE "scisa-isel"
#define PASS_NAME  "SCISA DAG->DAG Pattern Instruction Selection"

// Instruction Selector Implementation
namespace {

class SCISADAGToDAGISel : public SelectionDAGISel {

    /// Subtarget - Keep a pointer to the SCISASubtarget around so that we can
    /// make the right decision when generating code for different subtargets.
    const SCISASubtarget *Subtarget;

public:
    SCISADAGToDAGISel() = delete;

    explicit SCISADAGToDAGISel(SCISATargetMachine &TM)
        : SelectionDAGISel(TM),
          Subtarget(nullptr)
    {
    }

    bool runOnMachineFunction(MachineFunction &MF) override
    {
        // Reset the subtarget each time through.
        Subtarget = &MF.getSubtarget<SCISASubtarget>();
        return SelectionDAGISel::runOnMachineFunction(MF);
    }

    void PreprocessISelDAG() override;

    bool SelectInlineAsmMemoryOperand(const SDValue &Op, InlineAsm::ConstraintCode ConstraintCode, std::vector<SDValue> &OutOps) override;

private:
// Include the pieces autogenerated from the target description.
#include "SCISAGenDAGISel.inc"

    void Select(SDNode *N) override;

    // Complex Pattern for address selection.
    bool selectAddr(SDValue Addr, SDValue &Base, SDValue &Offset);
    bool selectFIAddr(SDValue Addr, SDValue &Base, SDValue &Offset);

    // Node preprocessing cases
    void preprocessLoad(SDNode *Node, SelectionDAG::allnodes_iterator &I);

    // Find constants from a constant structure
    typedef std::vector<unsigned char> val_vec_type;
    
    bool fillGenericConstant(const DataLayout &DL, const Constant *CV, val_vec_type &Vals, uint64_t Offset);
    
    bool fillConstantDataArray(const DataLayout &DL, const ConstantDataArray *CDA, val_vec_type &Vals, int Offset);
    
    bool fillConstantArray(const DataLayout &DL, const ConstantArray *CA, val_vec_type &Vals, int Offset);
    
    bool fillConstantStruct(const DataLayout &DL, const ConstantStruct *CS, val_vec_type &Vals, int Offset);
    
    bool getConstantFieldValue(const GlobalAddressSDNode *Node, uint64_t Offset, uint64_t Size, unsigned char *ByteSeq);
    // Mapping from ConstantStruct global value to corresponding byte-list values
    std::map<const void *, val_vec_type> cs_vals_;
};

class SCISADAGToDAGISelLegacy : public SelectionDAGISelLegacy {
public:
    static char ID;
    SCISADAGToDAGISelLegacy(SCISATargetMachine &TM)
        : SelectionDAGISelLegacy(ID, std::make_unique<SCISADAGToDAGISel>(TM))
    {
    }
};
} // namespace

char SCISADAGToDAGISelLegacy::ID = 0;

INITIALIZE_PASS(SCISADAGToDAGISelLegacy, DEBUG_TYPE, PASS_NAME, false, false)

// ComplexPattern used on SCISA Load/Store instructions
bool SCISADAGToDAGISel::selectAddr(SDValue Addr, SDValue &Base, SDValue &Offset)
{
    // if Address is FI, get the TargetFrameIndex.
    SDLoc DL(Addr);
    if (auto *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
        Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
        Offset = CurDAG->getTargetConstant(0, DL, MVT::i32);
        return true;
    }

    if (Addr.getOpcode() == ISD::TargetExternalSymbol || Addr.getOpcode() == ISD::TargetGlobalAddress) {
        return false;
    }

    // Addresses of the form Addr+const or Addr|const
    if (CurDAG->isBaseWithConstantOffset(Addr)) {
        auto *CN = cast<ConstantSDNode>(Addr.getOperand(1));
        if (isInt<32>(CN->getSExtValue())) {
            // If the first operand is a FI, get the TargetFI Node
            if (auto *FIN = dyn_cast<FrameIndexSDNode>(Addr.getOperand(0))) {
                Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
            }
            else {
                Base = Addr.getOperand(0);
            }

            Offset = CurDAG->getTargetConstant(CN->getSExtValue(), DL, MVT::i32);
            return true;
        }
    }

    Base = Addr;
    Offset = CurDAG->getTargetConstant(0, DL, MVT::i32);
    return true;
}

// ComplexPattern used on SCISA FI instruction
bool SCISADAGToDAGISel::selectFIAddr(SDValue Addr, SDValue &Base, SDValue &Offset)
{
    SDLoc DL(Addr);

    if (!CurDAG->isBaseWithConstantOffset(Addr)) {
        return false;
    }

    // Addresses of the form Addr+const or Addr|const
    auto *CN = cast<ConstantSDNode>(Addr.getOperand(1));
    if (isInt<32>(CN->getSExtValue())) {
        // If the first operand is a FI, get the TargetFI Node
        if (auto *FIN = dyn_cast<FrameIndexSDNode>(Addr.getOperand(0))) {
            Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
        }
        else {
            return false;
        }

        Offset = CurDAG->getTargetConstant(CN->getSExtValue(), DL, MVT::i32);
        return true;
    }

    return false;
}

bool SCISADAGToDAGISel::SelectInlineAsmMemoryOperand(const SDValue &Op, InlineAsm::ConstraintCode ConstraintCode, std::vector<SDValue> &OutOps)
{
    SDValue Op0;
    SDValue Op1;
    switch (ConstraintCode) {
        default:
            return true;
        case InlineAsm::ConstraintCode::m: // memory
            if (!selectAddr(Op, Op0, Op1)) {
                return true;
            }
            break;
    }

    SDLoc DL(Op);
    SDValue AluOp = CurDAG->getTargetConstant(ISD::ADD, DL, MVT::i32);
    OutOps.push_back(Op0);
    OutOps.push_back(Op1);
    OutOps.push_back(AluOp);
    return false;
}

void SCISADAGToDAGISel::Select(SDNode *Node)
{
    unsigned Opcode = Node->getOpcode();

    // If we have a custom node, we already have selected!
    if (Node->isMachineOpcode()) {
        LLVM_DEBUG(dbgs() << "== "; Node->dump(CurDAG); dbgs() << '\n');
        return;
    }

    // tablegen selection should be handled here.
    switch (Opcode) {
        default:
            break;
        case ISD::FrameIndex: {
            int FI = cast<FrameIndexSDNode>(Node)->getIndex();
            EVT VT = Node->getValueType(0);
            SDValue TFI = CurDAG->getTargetFrameIndex(FI, VT);
            unsigned Opc = SCISA::MOV_rr_32;
            if (Node->hasOneUse()) {
                CurDAG->SelectNodeTo(Node, Opc, VT, TFI);
                return;
            }
            ReplaceNode(Node, CurDAG->getMachineNode(Opc, SDLoc(Node), VT, TFI));
            return;
        }
    }

    // Select the default instruction
    SelectCode(Node);
}

void SCISADAGToDAGISel::preprocessLoad(SDNode *Node, SelectionDAG::allnodes_iterator &I)
{
    union {
        uint8_t c[4];
        uint16_t s;
        uint32_t i;
    } new_val; // hold up the constant values replacing loads.
    
    bool Replace = false;
    SDLoc DL(Node);
    const LoadSDNode *LD = cast<LoadSDNode>(Node);
    if (!LD->getMemOperand()->getSize().hasValue()) {
        return;
    }
    uint64_t Size = LD->getMemOperand()->getSize().getValue();

    if (!Size || Size > 4 || (Size & (Size - 1)) || !LD->isSimple()) {
        return;
    }

    SDNode *LDAddrNode = LD->getOperand(1).getNode();
    // Match LDAddr against either global_addr or (global_addr + offset)
    unsigned Op = LDAddrNode->getOpcode();
    if (Op == ISD::ADD) {
        SDValue OP1 = LDAddrNode->getOperand(0);
        SDValue OP2 = LDAddrNode->getOperand(1);

        // We want to find the pattern global_addr + offset
        SDNode *OP1N = OP1.getNode();
        if (OP1N->getOpcode() <= ISD::BUILTIN_OP_END || OP1N->getNumOperands() == 0) {
            return;
        }

        LLVM_DEBUG(dbgs() << "Check candidate load: "; LD->dump(); dbgs() << '\n');

        const GlobalAddressSDNode *GADN = dyn_cast<GlobalAddressSDNode>(OP1N->getOperand(0).getNode());
        const ConstantSDNode *CDN = dyn_cast<ConstantSDNode>(OP2.getNode());
        if (GADN && CDN) {
            Replace = getConstantFieldValue(GADN, CDN->getZExtValue(), Size, new_val.c);
        }
    }
    else if (LDAddrNode->getOpcode() > ISD::BUILTIN_OP_END && LDAddrNode->getNumOperands() > 0) {
        LLVM_DEBUG(dbgs() << "Check candidate load: "; LD->dump(); dbgs() << '\n');

        SDValue OP1 = LDAddrNode->getOperand(0);
        if (const GlobalAddressSDNode *GADN = dyn_cast<GlobalAddressSDNode>(OP1.getNode())) {
            Replace = getConstantFieldValue(GADN, 0, Size, new_val.c);
        }
    }

    if (!Replace) {
        return;
    }

    // replacing the old with a new value
    uint64_t Val = new_val.i;
    if (Size == 1) {
        Val = new_val.c[0];
    }
    else if (Size == 2) {
        Val = new_val.s;
    }

    LLVM_DEBUG(dbgs() << "Replacing load of size " << Size << " with constant " << Val << '\n');
    SDValue NVal = CurDAG->getConstant(Val, DL, LD->getValueType(0));

    // After replacement, the current node is dead, we need to
    // go backward one step to make iterator still work
    I--;
    SDValue From[] = { SDValue(Node, 0), SDValue(Node, 1) };
    SDValue To[] = { NVal, NVal };
    CurDAG->ReplaceAllUsesOfValuesWith(From, To, 2);
    I++;
    // It is safe to delete node now
    CurDAG->DeleteNode(Node);
}

void SCISADAGToDAGISel::PreprocessISelDAG()
{
    // Iterate through all nodes, interested in the following case:
    //
    //  . loads from ConstantStruct or ConstantArray of constructs
    //    which can be turns into constant itself, with this we can
    //    avoid reading from read-only section at runtime.
    //
    //  . Removing redundant AND for intrinsic narrow loads.
    for (SelectionDAG::allnodes_iterator I = CurDAG->allnodes_begin(), E = CurDAG->allnodes_end(); I != E;) {
        SDNode *Node = &*I++;
        unsigned Opcode = Node->getOpcode();
        if (Opcode == ISD::LOAD) {
            preprocessLoad(Node, I);
        }
    }
}

bool SCISADAGToDAGISel::getConstantFieldValue(const GlobalAddressSDNode *Node, uint64_t Offset, uint64_t Size, unsigned char *ByteSeq)
{
    const GlobalVariable *V = dyn_cast<GlobalVariable>(Node->getGlobal());

    if (!V || !V->hasInitializer() || !V->isConstant()) {
        return false;
    }

    const Constant *Init = V->getInitializer();
    const DataLayout &DL = CurDAG->getDataLayout();
    val_vec_type TmpVal;

    auto IT = cs_vals_.find(static_cast<const void *>(Init));
    if (IT != cs_vals_.end()) {
        TmpVal = IT->second;
    }
    else {
        uint64_t TotalSize = 0;
        if (const ConstantStruct *CS = dyn_cast<ConstantStruct>(Init)) {
            TotalSize = DL.getStructLayout(cast<StructType>(CS->getType()))->getSizeInBytes();
        }
        else if (const ConstantArray *CA = dyn_cast<ConstantArray>(Init)) {
            TotalSize = DL.getTypeAllocSize(CA->getType()->getElementType()) * CA->getNumOperands();
        }
        else {
            return false;
        }

        val_vec_type Vals(TotalSize, 0);
        if (fillGenericConstant(DL, Init, Vals, 0) == false) {
            return false;
        }
        cs_vals_[static_cast<const void *>(Init)] = Vals;
        TmpVal = std::move(Vals);
    }

    for (uint64_t I = Offset, J = 0; I < Offset + Size; I++, J++) {
        ByteSeq[J] = TmpVal[I];
    }

    return true;
}

bool SCISADAGToDAGISel::fillGenericConstant(const DataLayout &DL, const Constant *CV, val_vec_type &Vals, uint64_t Offset)
{
    uint64_t Size = DL.getTypeAllocSize(CV->getType());

    if (isa<ConstantAggregateZero>(CV) || isa<UndefValue>(CV)) {
        return true; // already done
    }

    if (const ConstantInt *CI = dyn_cast<ConstantInt>(CV)) {
        uint64_t Val = CI->getZExtValue();
        LLVM_DEBUG(dbgs() << "Byte array at offset " << Offset << " with value " << Val << '\n');

        if (Size > 4 || (Size & (Size - 1))) {
            return false;
        }

        // Store based on target endian
        for (uint64_t I = 0; I < Size; ++I) {
            Vals[Offset + I] = DL.isLittleEndian() ? ((Val >> (I * 4)) & 0xFF) : ((Val >> ((Size - I - 1) * 4)) & 0xFF);
        }
        return true;
    }

    if (const ConstantDataArray *CDA = dyn_cast<ConstantDataArray>(CV)) {
        return fillConstantDataArray(DL, CDA, Vals, Offset);
    }

    if (const ConstantArray *CA = dyn_cast<ConstantArray>(CV)) {
        return fillConstantArray(DL, CA, Vals, Offset);
    }

    if (const ConstantStruct *CVS = dyn_cast<ConstantStruct>(CV)) {
        return fillConstantStruct(DL, CVS, Vals, Offset);
    }

    return false;
}

bool SCISADAGToDAGISel::fillConstantDataArray(const DataLayout &DL, const ConstantDataArray *CDA, val_vec_type &Vals, int Offset)
{
    for (unsigned I = 0, E = CDA->getNumElements(); I != E; ++I) {
        if (fillGenericConstant(DL, CDA->getElementAsConstant(I), Vals, Offset) == false) {
            return false;
        }
        Offset += DL.getTypeAllocSize(CDA->getElementAsConstant(I)->getType());
    }

    return true;
}

bool SCISADAGToDAGISel::fillConstantArray(const DataLayout &DL, const ConstantArray *CA, val_vec_type &Vals, int Offset)
{
    for (unsigned I = 0, E = CA->getNumOperands(); I != E; ++I) {
        if (fillGenericConstant(DL, CA->getOperand(I), Vals, Offset) == false) {
            return false;
        }
        Offset += DL.getTypeAllocSize(CA->getOperand(I)->getType());
    }

    return true;
}

bool SCISADAGToDAGISel::fillConstantStruct(const DataLayout &DL, const ConstantStruct *CS, val_vec_type &Vals, int Offset)
{
    const StructLayout *Layout = DL.getStructLayout(CS->getType());
    for (unsigned I = 0, E = CS->getNumOperands(); I != E; ++I) {
        const Constant *Field = CS->getOperand(I);
        uint64_t SizeSoFar = Layout->getElementOffset(I);
        if (fillGenericConstant(DL, Field, Vals, Offset + SizeSoFar) == false) {
            return false;
        }
    }
    return true;
}

FunctionPass *llvm::createSCISAISelDag(SCISATargetMachine &TM)
{
    return new SCISADAGToDAGISelLegacy(TM);
}
